{"ast":null,"code":"let fs = require('fs');\n\nlet path = require('path');\n\nlet encodeVersion = require('./encodeVersion');\n\nlet getSDKFeatureCode = require('./getSDKFeatureCode');\n\nlet SDKCode = 'M'; // Constant per SDK\n\n/**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */\n\nfunction removePatchFromSemver(semVerStr) {\n  let parts = semVerStr.split('.');\n  return `${parts[0]}.${parts[1]}`;\n}\n/**\n * @description Gets the SDK signature by encoding the SDK version and node version\n * @param {{responsive:boolean}} features\n * @param {'default' | 'x.y.z' | 'x.y' | string} useSDKVersion Default uses package.json version\n * @param {'default' | 'x.y.z' | 'x.y' | string} useNodeVersion Default uses process.versions.node\n * @return {string} encodedSDK sdkVersionID\n */\n\n\nfunction getSDKVersionID(features = {}, useSDKVersion = 'default', useNodeVersion = 'default') {\n  try {\n    // allow to pass a custom SDKVersion\n    let pkgJSONFile = fs.readFileSync(path.join(__dirname, '../../../../package.json'), 'utf-8');\n    let sdkVersion = useSDKVersion === 'default' ? JSON.parse(pkgJSONFile).version : useSDKVersion; // allow to pass a custom nodeVersion\n\n    let nodeVersion = useNodeVersion === 'default' ? process.versions.node : useNodeVersion; // Node version should always be in x.y format\n\n    let twoPartNodeVersion = removePatchFromSemver(nodeVersion);\n    let encodedSDKVersion = encodeVersion(sdkVersion);\n    let encodedNodeVersion = encodeVersion(twoPartNodeVersion);\n    let featureCode = getSDKFeatureCode(features);\n    return `${SDKCode}${encodedSDKVersion}${encodedNodeVersion}${featureCode}`;\n  } catch (e) {\n    // Either SDK or Node versions were unparsable\n    return 'E';\n  }\n}\n\nmodule.exports = getSDKVersionID;","map":{"version":3,"sources":["/Users/dannyvera/Documents/general-assembly/sei/bees/unit_2/photo-collab-proj-2/PhotoCollaboration-SEI-Project2/photo-collab/node_modules/cloudinary/lib/utils/encoding/sdkVersionID/getSDKVersionID.js"],"names":["fs","require","path","encodeVersion","getSDKFeatureCode","SDKCode","removePatchFromSemver","semVerStr","parts","split","getSDKVersionID","features","useSDKVersion","useNodeVersion","pkgJSONFile","readFileSync","join","__dirname","sdkVersion","JSON","parse","version","nodeVersion","process","versions","node","twoPartNodeVersion","encodedSDKVersion","encodedNodeVersion","featureCode","e","module","exports"],"mappings":"AAAA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIG,iBAAiB,GAAGH,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAII,OAAO,GAAG,GAAd,C,CAAmB;;AAGnB;;;;;;AAKA,SAASC,qBAAT,CAA+BC,SAA/B,EAA0C;AACxC,MAAIC,KAAK,GAAGD,SAAS,CAACE,KAAV,CAAgB,GAAhB,CAAZ;AAEA,SAAQ,GAAED,KAAK,CAAC,CAAD,CAAI,IAAGA,KAAK,CAAC,CAAD,CAAI,EAA/B;AACD;AAED;;;;;;;;;AAOA,SAASE,eAAT,CAAyBC,QAAQ,GAAG,EAApC,EAAwCC,aAAa,GAAG,SAAxD,EAAmEC,cAAc,GAAG,SAApF,EAA+F;AAC7F,MAAI;AACF;AACA,QAAIC,WAAW,GAAGd,EAAE,CAACe,YAAH,CAAgBb,IAAI,CAACc,IAAL,CAAUC,SAAV,EAAqB,0BAArB,CAAhB,EAAkE,OAAlE,CAAlB;AAEA,QAAIC,UAAU,GAAGN,aAAa,KAAK,SAAlB,GAA8BO,IAAI,CAACC,KAAL,CAAWN,WAAX,EAAwBO,OAAtD,GAAgET,aAAjF,CAJE,CAMF;;AACA,QAAIU,WAAW,GAAGT,cAAc,KAAK,SAAnB,GAA+BU,OAAO,CAACC,QAAR,CAAiBC,IAAhD,GAAuDZ,cAAzE,CAPE,CASF;;AACA,QAAIa,kBAAkB,GAAGpB,qBAAqB,CAACgB,WAAD,CAA9C;AACA,QAAIK,iBAAiB,GAAGxB,aAAa,CAACe,UAAD,CAArC;AACA,QAAIU,kBAAkB,GAAGzB,aAAa,CAACuB,kBAAD,CAAtC;AACA,QAAIG,WAAW,GAAGzB,iBAAiB,CAACO,QAAD,CAAnC;AAEA,WAAQ,GAAEN,OAAQ,GAAEsB,iBAAkB,GAAEC,kBAAmB,GAAEC,WAAY,EAAzE;AACD,GAhBD,CAgBE,OAAOC,CAAP,EAAU;AACV;AACA,WAAO,GAAP;AACD;AACF;;AAEDC,MAAM,CAACC,OAAP,GAAiBtB,eAAjB","sourcesContent":["let fs = require('fs');\nlet path = require('path');\nlet encodeVersion = require('./encodeVersion');\nlet getSDKFeatureCode = require('./getSDKFeatureCode');\nlet SDKCode = 'M'; // Constant per SDK\n\n\n/**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */\nfunction removePatchFromSemver(semVerStr) {\n  let parts = semVerStr.split('.');\n\n  return `${parts[0]}.${parts[1]}`;\n}\n\n/**\n * @description Gets the SDK signature by encoding the SDK version and node version\n * @param {{responsive:boolean}} features\n * @param {'default' | 'x.y.z' | 'x.y' | string} useSDKVersion Default uses package.json version\n * @param {'default' | 'x.y.z' | 'x.y' | string} useNodeVersion Default uses process.versions.node\n * @return {string} encodedSDK sdkVersionID\n */\nfunction getSDKVersionID(features = {}, useSDKVersion = 'default', useNodeVersion = 'default') {\n  try {\n    // allow to pass a custom SDKVersion\n    let pkgJSONFile = fs.readFileSync(path.join(__dirname, '../../../../package.json'), 'utf-8');\n\n    let sdkVersion = useSDKVersion === 'default' ? JSON.parse(pkgJSONFile).version : useSDKVersion;\n\n    // allow to pass a custom nodeVersion\n    let nodeVersion = useNodeVersion === 'default' ? process.versions.node : useNodeVersion;\n\n    // Node version should always be in x.y format\n    let twoPartNodeVersion = removePatchFromSemver(nodeVersion);\n    let encodedSDKVersion = encodeVersion(sdkVersion);\n    let encodedNodeVersion = encodeVersion(twoPartNodeVersion);\n    let featureCode = getSDKFeatureCode(features);\n\n    return `${SDKCode}${encodedSDKVersion}${encodedNodeVersion}${featureCode}`;\n  } catch (e) {\n    // Either SDK or Node versions were unparsable\n    return 'E';\n  }\n}\n\nmodule.exports = getSDKVersionID;\n"]},"metadata":{},"sourceType":"script"}